From ba3a6c1da5c4b201efb62b8e24efc928a0c68919 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Mon, 13 Aug 2018 23:55:54 -0500
Subject: [PATCH 1/3] DONTMERGE third_party/node: Use system nodejs binary

Don't merge this upstream. Should eventually be replaced with
logic to determine if a suitable system node binary is present
and fall back to included ones if not.
---
 third_party/node/node.py | 11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

diff --git a/third_party/node/node.py b/third_party/node/node.py
index 8097e2c49acf..10e6a16eab12 100755
--- a/third_party/node/node.py
+++ b/third_party/node/node.py
@@ -10,11 +10,12 @@ import sys
 
 
 def GetBinaryPath():
-  return os_path.join(os_path.dirname(__file__), *{
-    'Darwin': ('mac', 'node-darwin-x64', 'bin', 'node'),
-    'Linux': ('linux', 'node-linux-x64', 'bin', 'node'),
-    'Windows': ('win', 'node.exe'),
-  }[platform.system()])
+  return "/usr/bin/node"
+  #return os_path.join(os_path.dirname(__file__), *{
+  #  'Darwin': ('mac', 'node-darwin-x64', 'bin', 'node'),
+  #  'Linux': ('linux', 'node-linux-x64', 'bin', 'node'),
+  #  'Windows': ('win', 'node.exe'),
+  #}[platform.system()])
 
 
 def RunNode(cmd_parts, stdout=None):
-- 
2.17.1

From f6c383f096eac04dae5b5bc560aba090c85e58de Mon Sep 17 00:00:00 2001
From: Timothy Pearson <tpearson@raptorengineering.com>
Date: Tue, 18 Sep 2018 15:12:34 -0500
Subject: [PATCH] Reenable VSX in libpng

---
 third_party/libpng/BUILD.gn                        |   5 +
 third_party/libpng/powerpc/filter_vsx_intrinsics.c | 767 +++++++++++++++++++++
 third_party/libpng/powerpc/powerpc_init.c          | 125 ++++
 3 files changed, 897 insertions(+)
 create mode 100644 third_party/libpng/powerpc/filter_vsx_intrinsics.c
 create mode 100644 third_party/libpng/powerpc/powerpc_init.c

diff --git a/third_party/libpng/BUILD.gn b/third_party/libpng/BUILD.gn
index ebd7bd5..38d00ec 100644
--- a/third_party/libpng/BUILD.gn
+++ b/third_party/libpng/BUILD.gn
@@ -86,6 +86,11 @@ source_set("libpng_sources") {
       "mips/filter_msa_intrinsics.c",
       "mips/mips_init.c",
     ]
+  } else if (current_cpu == "ppc64") {
+    sources += [
+      "powerpc/filter_vsx_intrinsics.c",
+      "powerpc/powerpc_init.c",
+    ]
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
diff --git a/third_party/libpng/powerpc/filter_vsx_intrinsics.c b/third_party/libpng/powerpc/filter_vsx_intrinsics.c
new file mode 100644
index 0000000..e3de496
--- /dev/null
+++ b/third_party/libpng/powerpc/filter_vsx_intrinsics.c
@@ -0,0 +1,767 @@
+/* filter_vsx_intrinsics.c - PowerPC optimised filter functions
+ *
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ * Last changed in libpng 1.6.29 [March 16, 2017]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+/* This code requires -maltivec and -mvsx on the command line: */
+#if PNG_POWERPC_VSX_IMPLEMENTATION == 1 /* intrinsics code from pngpriv.h */
+
+#include <altivec.h>
+
+#if PNG_POWERPC_VSX_OPT > 0
+
+#ifndef __VSX__
+#  error "This code requires VSX support (POWER7 and later). Please provide -mvsx compiler flag."
+#endif
+
+#define vec_ld_unaligned(vec,data) vec = vec_vsx_ld(0,data)
+#define vec_st_unaligned(vec,data) vec_vsx_st(vec,0,data)
+
+
+/* Functions in this file look at most 3 pixels (a,b,c) to predict the 4th (d).
+ * They're positioned like this:
+ *    prev:  c b
+ *    row:   a d
+ * The Sub filter predicts d=a, Avg d=(a+b)/2, and Paeth predicts d to be
+ * whichever of a, b, or c is closest to p=a+b-c.
+ * ( this is taken from ../intel/filter_sse2_intrinsics.c )
+ */
+
+#define vsx_declare_common_vars(row_info,row,prev_row,offset) \
+   png_byte i;\
+   png_bytep rp = row + offset;\
+   png_const_bytep pp = prev_row;\
+   png_size_t unaligned_top = 16 - (((png_size_t)rp % 16));\
+   png_size_t istop;\
+   if(unaligned_top == 16)\
+      unaligned_top = 0;\
+   istop = row_info->rowbytes;\
+   if((unaligned_top < istop))\
+      istop -= unaligned_top;\
+   else{\
+      unaligned_top = istop;\
+      istop = 0;\
+   }
+
+void png_read_filter_row_up_vsx(png_row_infop row_info, png_bytep row,
+                                png_const_bytep prev_row)
+{
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vsx_declare_common_vars(row_info,row,prev_row,0)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      rp_vec = vec_add(rp_vec,pp_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      pp += 16;
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+   {
+      /* If byte count of row is not divisible by 16
+       * we will process remaining part as usual
+       */
+      for (i = 0; i < istop; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*pp++)) & 0xff);
+         rp++;
+      }
+}
+
+}
+
+static const vector unsigned char VSX_LEFTSHIFTED1_4 = {16,16,16,16, 0, 1, 2, 3,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_4 = {16,16,16,16,16,16,16,16, 4, 5, 6, 7,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 8, 9,10,11};
+
+static const vector unsigned char VSX_LEFTSHIFTED1_3 = {16,16,16, 0, 1, 2,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED2_3 = {16,16,16,16,16,16, 3, 4, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 6, 7, 8,16,16,16,16};
+static const vector unsigned char VSX_LEFTSHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 9,10,11,16};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_4 = {16,16,16,16, 4, 5, 6, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_4 = {16,16,16,16,16,16,16,16, 8, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_4 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,15};
+
+static const vector unsigned char VSX_NOT_SHIFTED1_3 = {16,16,16, 3, 4, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED2_3 = {16,16,16,16,16,16, 6, 7, 8,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED3_3 = {16,16,16,16,16,16,16,16,16, 9,10,11,16,16,16,16};
+static const vector unsigned char VSX_NOT_SHIFTED4_3 = {16,16,16,16,16,16,16,16,16,16,16,16,12,13,14,16};
+
+static const vector unsigned char VSX_CHAR_ZERO = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
+#ifdef __LITTLE_ENDIAN__
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = { 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = { 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {12,16,13,16,14,16,15,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 0, 2, 4, 6,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 0, 2, 4, 6,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4, 6};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = { 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = { 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = { 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {12,16,13,16,14,16,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 0, 2, 4,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 0, 2, 4,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 0, 2, 4,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 0, 2, 4,16};
+
+#elif defined(__BIG_ENDIAN__)
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_4 = {16, 4,16, 5,16, 6,16, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_4 = {16, 8,16, 9,16,10,16,11,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_4 = {16,12,16,13,16,14,16,15,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_4 = {16,16,16,16, 1, 3, 5, 7,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_4 = {16,16,16,16,16,16,16,16, 1, 3, 5, 7,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_4 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5, 7};
+
+static const vector unsigned char VSX_CHAR_TO_SHORT1_3 = {16, 3,16, 4,16, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT2_3 = {16, 6,16, 7,16, 8,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT3_3 = {16, 9,16,10,16,11,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_CHAR_TO_SHORT4_3 = {16,12,16,13,16,14,16,16,16,16,16,16,16,16,16,16};
+
+static const vector unsigned char VSX_SHORT_TO_CHAR1_3 = {16,16,16, 1, 3, 5,16,16,16,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR2_3 = {16,16,16,16,16,16, 1, 3, 5,16,16,16,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR3_3 = {16,16,16,16,16,16,16,16,16, 1, 3, 5,16,16,16,16};
+static const vector unsigned char VSX_SHORT_TO_CHAR4_3 = {16,16,16,16,16,16,16,16,16,16,16,16, 1, 3, 5,16};
+
+#endif
+
+#define vsx_char_to_short(vec,offset,bpp) (vector unsigned short)vec_perm((vec),VSX_CHAR_ZERO,VSX_CHAR_TO_SHORT##offset##_##bpp)
+#define vsx_short_to_char(vec,offset,bpp) vec_perm(((vector unsigned char)(vec)),VSX_CHAR_ZERO,VSX_SHORT_TO_CHAR##offset##_##bpp)
+
+#ifdef PNG_USE_ABS
+#  define vsx_abs(number) abs(number)
+#else
+#  define vsx_abs(number) (number > 0) ? (number) : -(number)
+#endif
+
+void png_read_filter_row_sub4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp - bpp))) & 0xff);
+         rp++;
+      }
+
+}
+
+void png_read_filter_row_sub3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 3;
+
+   vector unsigned char rp_vec;
+   vector unsigned char part_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+
+   PNG_UNUSED(pp)
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+      rp -= bpp;
+
+      rp_vec = vec_ld(0,rp);
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+      rp_vec = vec_add(rp_vec,part_vec);
+
+      vec_st(rp_vec,0,rp);
+      rp += 15;
+      istop -= 16;
+
+      /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+       * be proceeded manually
+       */
+      *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+      rp++;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) + (int)(*(rp-bpp))) & 0xff);
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg4_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned char pp_part_vec;
+   vector unsigned char rp_part_vec;
+   vector unsigned char avg_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   for (i = 0; i < bpp; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         ((int)(*pp++) / 2 )) & 0xff);
+
+      rp++;
+   }
+
+   /* Altivec operations require 16-byte aligned data
+    * but input can be unaligned. So we calculate
+    * unaligned part as usual.
+    */
+   for (i = 0; i < unaligned_top; i++)
+   {
+      *rp = (png_byte)(((int)(*rp) +
+         (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+      rp++;
+   }
+
+   /* Using SIMD while we can */
+   while( istop >= 16 )
+   {
+      for(i=0;i < bpp ; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+      rp -= bpp;
+      pp -= bpp;
+
+      vec_ld_unaligned(pp_vec,pp);
+      rp_vec = vec_ld(0,rp);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_4);
+      pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_4);
+      avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+      avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+      rp_vec = vec_add(rp_vec,avg_vec);
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop  > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         *rp = (png_byte)(((int)(*rp) +
+            (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+         rp++;
+      }
+}
+
+void png_read_filter_row_avg3_vsx(png_row_infop row_info, png_bytep row,
+                                  png_const_bytep prev_row)
+{
+  const png_byte bpp = 3;
+
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned char pp_part_vec;
+  vector unsigned char rp_part_vec;
+  vector unsigned char avg_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  for (i = 0; i < bpp; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        ((int)(*pp++) / 2 )) & 0xff);
+
+     rp++;
+  }
+
+  /* Altivec operations require 16-byte aligned data
+   * but input can be unaligned. So we calculate
+   * unaligned part as usual.
+   */
+  for (i = 0; i < unaligned_top; i++)
+  {
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+     rp++;
+  }
+
+  /* Using SIMD while we can */
+  while( istop >= 16 )
+  {
+     for(i=0;i < bpp ; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+     rp -= bpp;
+     pp -= bpp;
+
+     vec_ld_unaligned(pp_vec,pp);
+     rp_vec = vec_ld(0,rp);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED1_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED1_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED2_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED2_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED3_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED3_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     rp_part_vec = vec_perm(rp_vec,VSX_CHAR_ZERO,VSX_LEFTSHIFTED4_3);
+     pp_part_vec = vec_perm(pp_vec,VSX_CHAR_ZERO,VSX_NOT_SHIFTED4_3);
+     avg_vec = vec_avg(rp_part_vec,pp_part_vec);
+     avg_vec = vec_sub(avg_vec, vec_and(vec_xor(rp_part_vec,pp_part_vec),vec_splat_u8(1)));
+     rp_vec = vec_add(rp_vec,avg_vec);
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     *rp = (png_byte)(((int)(*rp) +
+        (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+     rp++;
+  }
+
+  if(istop  > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        *rp = (png_byte)(((int)(*rp) +
+           (int)(*pp++ + *(rp-bpp)) / 2 ) & 0xff);
+
+        rp++;
+     }
+}
+
+/* Bytewise c ? t : e. */
+#define if_then_else(c,t,e) vec_sel(e,t,c)
+
+#define vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp) {\
+      c = *(pp - bpp);\
+      a = *(rp - bpp);\
+      b = *pp++;\
+      p = b - c;\
+      pc = a - c;\
+      pa = vsx_abs(p);\
+      pb = vsx_abs(pc);\
+      pc = vsx_abs(p + pc);\
+      if (pb < pa) pa = pb, a = b;\
+      if (pc < pa) a = c;\
+      a += *rp;\
+      *rp++ = (png_byte)a;\
+      }
+
+void png_read_filter_row_paeth4_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+   const png_byte bpp = 4;
+
+   int a, b, c, pa, pb, pc, p;
+   vector unsigned char rp_vec;
+   vector unsigned char pp_vec;
+   vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+   vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+   vsx_declare_common_vars(row_info,row,prev_row,bpp)
+   rp -= bpp;
+   if(istop >= bpp)
+      istop -= bpp;
+
+   /* Process the first pixel in the row completely (this is the same as 'up'
+    * because there is only one candidate predictor for the first row).
+    */
+   for(i = 0; i < bpp ; i++)
+   {
+      *rp = (png_byte)( *rp + *pp);
+      rp++;
+      pp++;
+   }
+
+   for(i = 0; i < unaligned_top ; i++)
+   {
+      vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+   }
+
+   while( istop >= 16)
+   {
+      for(i = 0; i < bpp ; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+
+      rp -= bpp;
+      pp -= bpp;
+      rp_vec = vec_ld(0,rp);
+      vec_ld_unaligned(pp_vec,pp);
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_4),1,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_4),1,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_4),2,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_4),2,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,4)));
+
+      a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_4),3,4);
+      c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_4),3,4);
+      pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+      pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+      pc_vec = vec_add(pa_vec,pb_vec);
+      pa_vec = vec_abs(pa_vec);
+      pb_vec = vec_abs(pb_vec);
+      pc_vec = vec_abs(pc_vec);
+      smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+      nearest_vec =  if_then_else(
+            vec_cmpeq(pa_vec,smallest_vec),
+            a_vec,
+            if_then_else(
+              vec_cmpeq(pb_vec,smallest_vec),
+              b_vec,
+              c_vec
+              )
+            );
+      rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,4)));
+
+      vec_st(rp_vec,0,rp);
+
+      rp += 16;
+      pp += 16;
+      istop -= 16;
+   }
+
+   if(istop > 0)
+      for (i = 0; i < istop % 16; i++)
+      {
+         vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+      }
+}
+
+void png_read_filter_row_paeth3_vsx(png_row_infop row_info, png_bytep row,
+   png_const_bytep prev_row)
+{
+  const png_byte bpp = 3;
+
+  int a, b, c, pa, pb, pc, p;
+  vector unsigned char rp_vec;
+  vector unsigned char pp_vec;
+  vector unsigned short a_vec,b_vec,c_vec,nearest_vec;
+  vector signed short pa_vec,pb_vec,pc_vec,smallest_vec;
+
+  vsx_declare_common_vars(row_info,row,prev_row,bpp)
+  rp -= bpp;
+  if(istop >= bpp)
+     istop -= bpp;
+
+  /* Process the first pixel in the row completely (this is the same as 'up'
+   * because there is only one candidate predictor for the first row).
+   */
+  for(i = 0; i < bpp ; i++)
+  {
+     *rp = (png_byte)( *rp + *pp);
+     rp++;
+     pp++;
+  }
+
+  for(i = 0; i < unaligned_top ; i++)
+  {
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  while( istop >= 16)
+  {
+     for(i = 0; i < bpp ; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+
+     rp -= bpp;
+     pp -= bpp;
+     rp_vec = vec_ld(0,rp);
+     vec_ld_unaligned(pp_vec,pp);
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED1_3),1,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED1_3),1,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,1,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED2_3),2,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED2_3),2,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,2,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED3_3),3,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED3_3),3,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,3,3)));
+
+     a_vec = vsx_char_to_short(vec_perm(rp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     b_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_NOT_SHIFTED4_3),4,3);
+     c_vec = vsx_char_to_short(vec_perm(pp_vec , VSX_CHAR_ZERO , VSX_LEFTSHIFTED4_3),4,3);
+     pa_vec = (vector signed short) vec_sub(b_vec,c_vec);
+     pb_vec = (vector signed short) vec_sub(a_vec , c_vec);
+     pc_vec = vec_add(pa_vec,pb_vec);
+     pa_vec = vec_abs(pa_vec);
+     pb_vec = vec_abs(pb_vec);
+     pc_vec = vec_abs(pc_vec);
+     smallest_vec = vec_min(pc_vec, vec_min(pa_vec,pb_vec));
+     nearest_vec =  if_then_else(
+           vec_cmpeq(pa_vec,smallest_vec),
+           a_vec,
+           if_then_else(
+             vec_cmpeq(pb_vec,smallest_vec),
+             b_vec,
+             c_vec
+             )
+           );
+     rp_vec = vec_add(rp_vec,(vsx_short_to_char(nearest_vec,4,3)));
+
+     vec_st(rp_vec,0,rp);
+
+     rp += 15;
+     pp += 15;
+     istop -= 16;
+
+     /* Since 16 % bpp = 16 % 3 = 1, last element of array must
+      * be proceeded manually
+      */
+     vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+  }
+
+  if(istop > 0)
+     for (i = 0; i < istop % 16; i++)
+     {
+        vsx_paeth_process(rp,pp,a,b,c,pa,pb,pc,bpp)
+     }
+}
+
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* PNG_POWERPC_VSX_IMPLEMENTATION == 1 (intrinsics) */
+#endif /* READ */
diff --git a/third_party/libpng/powerpc/powerpc_init.c b/third_party/libpng/powerpc/powerpc_init.c
new file mode 100644
index 0000000..0701617
--- /dev/null
+++ b/third_party/libpng/powerpc/powerpc_init.c
@@ -0,0 +1,125 @@
+
+/* powerpc_init.c - POWERPC optimised filter functions
+ *
+ * Copyright (c) 2017 Glenn Randers-Pehrson
+ * Written by Vadim Barkov, 2017.
+ * Last changed in libpng 1.6.29 [March 16, 2017]
+ *
+ * This code is released under the libpng license.
+ * For conditions of distribution and use, see the disclaimer
+ * and license in png.h
+ */
+/* Below, after checking __linux__, various non-C90 POSIX 1003.1 functions are
+ * called.
+ */
+#define _POSIX_SOURCE 1
+
+#include <stdio.h>
+#include "../pngpriv.h"
+
+#ifdef PNG_READ_SUPPORTED
+
+#if PNG_POWERPC_VSX_OPT > 0
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED /* Do run-time checks */
+/* WARNING: it is strongly recommended that you do not build libpng with
+ * run-time checks for CPU features if at all possible.  In the case of the PowerPC
+ * VSX instructions there is no processor-specific way of detecting the
+ * presence of the required support, therefore run-time detection is extremely
+ * OS specific.
+ *
+ * You may set the macro PNG_POWERPC_VSX_FILE to the file name of file containing
+ * a fragment of C source code which defines the png_have_vsx function.  There
+ * are a number of implementations in contrib/powerpc-vsx, but the only one that
+ * has partial support is contrib/powerpc-vsx/linux.c - a generic Linux
+ * implementation which reads /proc/cpufino.
+ */
+#ifndef PNG_POWERPC_VSX_FILE
+#  ifdef __linux__
+#     define  PNG_POWERPC_VSX_FILE "contrib/powerpc-vsx/linux_aux.c"
+#  endif
+#endif
+
+#ifdef PNG_POWERPC_VSX_FILE
+
+#include <signal.h> /* for sig_atomic_t */
+static int png_have_vsx(png_structp png_ptr);
+#include PNG_POWERPC_VSX_FILE
+
+#else  /* PNG_POWERPC_VSX_FILE */
+#  error "PNG_POWERPC_VSX_FILE undefined: no support for run-time POWERPC VSX checks"
+#endif /* PNG_POWERPC_VSX_FILE */
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+void
+png_init_filter_functions_vsx(png_structp pp, unsigned int bpp)
+{
+   /* The switch statement is compiled in for POWERPC_VSX_API, the call to
+    * png_have_vsx is compiled in for POWERPC_VSX_CHECK. If both are defined
+    * the check is only performed if the API has not set the PowerPC option on
+    * or off explicitly. In this case the check controls what happens.
+    */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+   switch ((pp->options >> PNG_POWERPC_VSX) & 3)
+   {
+      case PNG_OPTION_UNSET:
+         /* Allow the run-time check to execute if it has been enabled -
+          * thus both API and CHECK can be turned on.  If it isn't supported
+          * this case will fall through to the 'default' below, which just
+          * returns.
+          */
+#endif /* PNG_POWERPC_VSX_API_SUPPORTED */
+#ifdef PNG_POWERPC_VSX_CHECK_SUPPORTED
+         {
+            static volatile sig_atomic_t no_vsx = -1; /* not checked */
+
+            if (no_vsx < 0)
+               no_vsx = !png_have_vsx(pp);
+
+            if (no_vsx)
+               return;
+         }
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+         break;
+#endif
+#endif /* PNG_POWERPC_VSX_CHECK_SUPPORTED */
+
+#ifdef PNG_POWERPC_VSX_API_SUPPORTED
+      default: /* OFF or INVALID */
+         return;
+
+      case PNG_OPTION_ON:
+         /* Option turned on */
+         break;
+   }
+#endif
+
+   /* IMPORTANT: any new internal functions used here must be declared using
+    * PNG_INTERNAL_FUNCTION in ../pngpriv.h.  This is required so that the
+    * 'prefix' option to configure works:
+    *
+    *    ./configure --with-libpng-prefix=foobar_
+    *
+    * Verify you have got this right by running the above command, doing a build
+    * and examining pngprefix.h; it must contain a #define for every external
+    * function you add.  (Notice that this happens automatically for the
+    * initialization function.)
+    */
+   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_vsx;
+
+   if (bpp == 3)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth3_vsx;
+   }
+
+   else if (bpp == 4)
+   {
+      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_vsx;
+      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] = png_read_filter_row_paeth4_vsx;
+   }
+}
+#endif /* PNG_POWERPC_VSX_OPT > 0 */
+#endif /* READ */
-- 
2.7.4

--- a/third_party/angle/src/libANGLE/Constants.h
+++ b/third_party/angle/src/libANGLE/Constants.h
@@ -9,6 +9,7 @@
 #ifndef LIBANGLE_CONSTANTS_H_
 #define LIBANGLE_CONSTANTS_H_
 
+#include <cstddef>
 #include "common/platform.h"
 
 namespace gl
From 4fcc19598eb97a47fe6612912ba1e4d895e14860 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawn@anastas.io>
Date: Sun, 17 Feb 2019 23:08:33 -0600
Subject: [PATCH] third_party/boringssl: Properly detect ppc64le in BUILD.gn

---
 third_party/boringssl/BUILD.gn | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/third_party/boringssl/BUILD.gn b/third_party/boringssl/BUILD.gn
index 1afad40684..7c35904eec 100644
--- a/third_party/boringssl/BUILD.gn
+++ b/third_party/boringssl/BUILD.gn
@@ -103,6 +103,13 @@ if (is_win && !is_msan && current_cpu != "arm64") {
       } else {
         public_configs = [ ":no_asm_config" ]
       }
+    } else if (current_cpu == "ppc64") {
+      if (is_linux) {
+        # TODO: ppc64 (be) check
+        sources += crypto_sources_linux_ppc64le
+      } else {
+        public_configs = [ ":no_asm_config" ]
+      }
     } else {
       public_configs = [ ":no_asm_config" ]
     }
-- 
2.20.1

From cc613c2e3bac8d4d1ff153700b819f964435923a Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Tue, 4 Sep 2018 18:16:07 -0500
Subject: [PATCH] third_party/libvpx: Properly generate gni on ppc64

---
 third_party/libvpx/BUILD.gn        |  2 ++
 third_party/libvpx/generate_gni.sh | 10 ++++++++++
 2 files changed, 12 insertions(+)

diff --git a/third_party/libvpx/BUILD.gn b/third_party/libvpx/BUILD.gn
index c1b718e..db3b003 100644
--- a/third_party/libvpx/BUILD.gn
+++ b/third_party/libvpx/BUILD.gn
@@ -341,6 +341,8 @@ static_library("libvpx") {
     } else {
       sources = libvpx_srcs_arm64
     }
+  } else if (current_cpu == "ppc64") {
+    sources = libvpx_srcs_ppc64
   }
 
   configs -= [ "//build/config/compiler:chromium_code" ]
   configs += [ "//build/config/compiler:no_chromium_code" ]
diff --git a/third_party/libvpx/generate_gni.sh b/third_party/libvpx/generate_gni.sh
index 2c94f6f685a3..c1758c6f193a 100755
--- a/third_party/libvpx/generate_gni.sh
+++ b/third_party/libvpx/generate_gni.sh
@@ -350,6 +350,7 @@ gen_config_files linux/arm-neon-cpu-detect "--target=armv7-linux-gcc --enable-ru
 gen_config_files linux/arm64 "--target=armv8-linux-gcc ${all_platforms}"
 gen_config_files linux/mipsel "--target=mips32-linux-gcc ${all_platforms}"
 gen_config_files linux/mips64el "--target=mips64-linux-gcc ${all_platforms}"
+gen_config_files linux/ppc64 "--target=ppc64le-linux-gcc ${all_platforms}"
 gen_config_files linux/generic "--target=generic-gnu $HIGHBD ${all_platforms}"
 gen_config_files win/ia32 "--target=x86-win32-vs12 ${all_platforms} ${x86_platforms}"
 gen_config_files win/x64 "--target=x86_64-win64-vs12 ${all_platforms} ${x86_platforms}"
@@ -372,6 +373,7 @@ lint_config linux/arm-neon-cpu-detect
 lint_config linux/arm64
 lint_config linux/mipsel
 lint_config linux/mips64el
+lint_config linux/ppc64
 lint_config linux/generic
 lint_config win/ia32
 lint_config win/x64
@@ -395,6 +397,7 @@ gen_rtcd_header linux/arm-neon-cpu-detect armv7
 gen_rtcd_header linux/arm64 armv8
 gen_rtcd_header linux/mipsel mipsel
 gen_rtcd_header linux/mips64el mips64el
+gen_rtcd_header linux/ppc64 ppc
 gen_rtcd_header linux/generic generic
 gen_rtcd_header win/ia32 x86
 gen_rtcd_header win/x64 x86_64
@@ -464,6 +467,13 @@ if [ -z $ONLY_CONFIGS ]; then
 
   echo "MIPS64 source list is identical to MIPS source list. No need to generate it."
 
+  echo "Generate ppc64 source list."
+  config=$(print_config_basic linux/ppc64)
+  make_clean
+  make libvpx_srcs.txt target=libs $config > /dev/null
+  convert_srcs_to_project_files libvpx_srcs.txt libvpx_srcs_ppc64
+
+
   echo "Generate NaCl source list."
   config=$(print_config_basic nacl)
   make_clean
-- 
2.17.1

--- a/third_party/lss/linux_syscall_support.h
+++ b/third_party/lss/linux_syscall_support.h
@@ -3905,7 +3905,7 @@
       LSS_REG(2, buf);
       LSS_BODY(void*, mmap2, "0"(__r2));
     }
-#else
+#elif !defined(__powerpc64__) /* ppc64 doesn't have mmap2 */
     #define __NR__mmap2 __NR_mmap2
     LSS_INLINE _syscall6(void*, _mmap2,            void*, s,
                          size_t,                   l, int,               p,
@@ -4036,7 +4036,7 @@
   #if defined(__i386__) ||                                                    \
       defined(__ARM_ARCH_3__) || defined(__ARM_EABI__) ||                     \
      (defined(__mips__) && _MIPS_SIM == _MIPS_SIM_ABI32) ||                   \
-      defined(__PPC__) ||                                                     \
+     (defined(__PPC__) && !defined(__powerpc64__)) ||                                                     \
      (defined(__s390__) && !defined(__s390x__))
     /* On these architectures, implement mmap() with mmap2(). */
     LSS_INLINE void* LSS_NAME(mmap)(void *s, size_t l, int p, int f, int d,
From 63e63a70766f3059ce5f1d06a95988ecf909b298 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawn@anastas.io>
Date: Wed, 24 Apr 2019 21:17:23 -0500
Subject: [PATCH] third_party/pffft: Include altivec.h on ppc64 with SIMD
 enabled

---
 third_party/pffft/src/pffft.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/third_party/pffft/src/pffft.c b/third_party/pffft/src/pffft.c
index bdac4d7849..51e0f2cacc 100644
--- a/third_party/pffft/src/pffft.c
+++ b/third_party/pffft/src/pffft.c
@@ -100,6 +100,7 @@
    Altivec support macros 
 */
 #if !defined(PFFFT_SIMD_DISABLE) && (defined(__ppc__) || defined(__ppc64__))
+#include <altivec.h>
 typedef vector float v4sf;
 #  define SIMD_SZ 4
 #  define VZERO() ((vector float) vec_splat_u8(0))
-- 
2.21.0

From 0e71c67f0918f0d6ea70981dac16ee5b0ddf9df9 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawn@anastas.io>
Date: Mon, 11 Mar 2019 13:20:31 -0500
Subject: [PATCH] xf86drm.c: Fix build on newer glibc

---
 xf86drm.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/third_party/libdrm/src/xf86drm.c b/xf86drm.c
index 1e87610b..d1283f25 100644
--- a/third_party/libdrm/src/xf86drm.c
+++ a/third_party/libdrm/src/xf86drm.c
@@ -54,10 +54,10 @@
 #include <sys/ioctl.h>
 #include <sys/time.h>
 #include <stdarg.h>
-#ifdef MAJOR_IN_MKDEV
+#if __has_include(<sys/mkdev.h>)
 #include <sys/mkdev.h>
 #endif
-#ifdef MAJOR_IN_SYSMACROS
+#if __has_include(<sys/sysmacros.h>)
 #include <sys/sysmacros.h>
 #endif
 #include <math.h>
-- 
2.21.0

From 2a4d4482c2a8e9dc9a6bf0b6c3b3f26dfa140a15 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Mon, 10 Sep 2018 01:03:42 -0500
Subject: [PATCH 2/6] third_party/libvpx: Add ppc64 sources to gni

---
 third_party/libvpx/libvpx_srcs.gni | 358 +++++++++++++++++++++++++++++
 1 file changed, 358 insertions(+)

diff --git a/third_party/libvpx/libvpx_srcs.gni b/third_party/libvpx/libvpx_srcs.gni
index cf7e7d182e9f..1ac02485ec6e 100644
--- a/third_party/libvpx/libvpx_srcs.gni
+++ b/third_party/libvpx/libvpx_srcs.gni
@@ -2892,6 +2892,364 @@ libvpx_srcs_mips = [
   "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.h",
 ]
 libvpx_srcs_mips_assembly = []
+libvpx_srcs_ppc64 = [
+  "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/blockd.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/blockd.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/coefupdateprobs.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/common.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/copy_c.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/default_coef_probs.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/dequantize.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropy.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropy.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymode.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymode.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymv.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/entropymv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/extend.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/extend.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/filter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/filter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/findnearmv.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/findnearmv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/generic/systemdependent.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/header.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/idct_blk.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/idctllm.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/invtrans.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/loopfilter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/loopfilter_filters.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/mbpitch.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/mfqe.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/modecont.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/modecont.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/mv.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyx.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyxc_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/onyxd.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/postproc.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/postproc.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/ppflags.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/quant_common.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/quant_common.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconinter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconinter.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra4x4.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/reconintra4x4.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/rtcd.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/setupintrarecon.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/setupintrarecon.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/swapyv12buffer.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/swapyv12buffer.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/systemdependent.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/threading.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/treecoder.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/treecoder.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_entropymodedata.h",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vp8/common/vp8_skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/dboolhuff.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/dboolhuff.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodemv.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decodemv.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/decoderthreading.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/detokenize.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/detokenize.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/onyxd_if.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/onyxd_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/threading.c",
+  "//third_party/libvpx/source/libvpx/vp8/decoder/treereader.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/bitstream.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/bitstream.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/block.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/boolhuff.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/boolhuff.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct_value_cost.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/dct_value_tokens.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/defaultcoefcounts.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/denoising.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/denoising.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeintra.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodeintra.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemb.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemb.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemv.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/encodemv.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ethreading.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ethreading.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/firstpass.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/lookahead.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/lookahead.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mcomp.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mcomp.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/modecosts.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/modecosts.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mr_dissim.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/mr_dissim.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/onyx_if.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/onyx_int.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/pickinter.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/pickinter.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/picklpf.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/picklpf.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/quantize.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ratectrl.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/ratectrl.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/rdopt.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/rdopt.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/segmentation.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/segmentation.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/tokenize.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/tokenize.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/treewriter.c",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/treewriter.h",
+  "//third_party/libvpx/source/libvpx/vp8/encoder/vp8_quantize.c",
+  "//third_party/libvpx/source/libvpx/vp8/vp8_cx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp8/vp8_dx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/ppc/vp9_idct_vsx.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_alloccommon.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_alloccommon.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_blockd.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_blockd.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common_data.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_common_data.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropy.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropy.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymode.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymode.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymv.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_entropymv.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_enums.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_filter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_filter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_frame_buffers.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_frame_buffers.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_idct.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_idct.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_loopfilter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mfqe.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mfqe.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mv.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mvref_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_mvref_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_onyxc_int.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_postproc.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_postproc.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_ppflags.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_pred_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_pred_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_quant_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_quant_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconinter.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconinter.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconintra.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_reconintra.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scale.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scale.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scan.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_scan.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_seg_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_seg_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_thread_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_thread_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_tile_common.c",
+  "//third_party/libvpx/source/libvpx/vp9/common/vp9_tile_common.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodemv.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decodemv.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decoder.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_decoder.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_detokenize.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_detokenize.h",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_dsubexp.c",
+  "//third_party/libvpx/source/libvpx/vp9/decoder/vp9_dsubexp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/ppc/vp9_quantize_vsx.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_alt_ref_aq.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_alt_ref_aq.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_360.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_360.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_complexity.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_complexity.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_cyclicrefresh.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_cyclicrefresh.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_variance.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_aq_variance.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_bitstream.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_bitstream.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_block.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_context_tree.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_context_tree.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_cost.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_cost.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_dct.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_denoiser.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_denoiser.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodeframe.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemb.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemb.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemv.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encodemv.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encoder.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_encoder.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ethread.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ethread.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_extend.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_extend.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_firstpass.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_frame_scale.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_job_queue.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_lookahead.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_lookahead.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mbgraph.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mcomp.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_mcomp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_multi_thread.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_multi_thread.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_noise_estimate.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_noise_estimate.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_picklpf.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_picklpf.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_pickmode.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_pickmode.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_quantize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_quantize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ratectrl.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_ratectrl.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rd.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rd.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rdopt.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_rdopt.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_resize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_resize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_segmentation.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_segmentation.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_speed_features.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_speed_features.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_subexp.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_subexp.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_svc_layercontext.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_svc_layercontext.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_temporal_filter.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_tokenize.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_tokenize.h",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_treewriter.c",
+  "//third_party/libvpx/source/libvpx/vp9/encoder/vp9_treewriter.h",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_cx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_dx_iface.c",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_dx_iface.h",
+  "//third_party/libvpx/source/libvpx/vp9/vp9_iface_common.h",
+  "//third_party/libvpx/source/libvpx/vpx/internal/vpx_codec_internal.h",
+  "//third_party/libvpx/source/libvpx/vpx/src/svc_encodeframe.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_codec.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_decoder.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_encoder.c",
+  "//third_party/libvpx/source/libvpx/vpx/src/vpx_image.c",
+  "//third_party/libvpx/source/libvpx/vpx/svc_context.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8cx.h",
+  "//third_party/libvpx/source/libvpx/vpx/vp8dx.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_codec.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_decoder.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_encoder.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_frame_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_image.h",
+  "//third_party/libvpx/source/libvpx/vpx/vpx_integer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/add_noise.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/avg.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader_buffer.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitreader_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter_buffer.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/bitwriter_buffer.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/deblock.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/fwd_txfm.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/fwd_txfm.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/intrapred.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/inv_txfm.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/inv_txfm.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/loopfilter.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/postproc.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/bitdepth_conversion_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/deblock_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/fdct32x32_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/hadamard_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/intrapred_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/inv_txfm_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/quantize_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/sad_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/subtract_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/transpose_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/txfm_common_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/types_vsx.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/variance_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/ppc/vpx_convolve_vsx.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/prob.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/prob.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/psnr.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/psnr.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/quantize.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/quantize.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/sad.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/skin_detection.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/skin_detection.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/subtract.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/sum_squares.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/txfm_common.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/variance.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/variance.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_convolve.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_convolve.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_dsp_common.h",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_dsp_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vpx_dsp/vpx_filter.h",
+  "//third_party/libvpx/source/libvpx/vpx_mem/include/vpx_mem_intrnl.h",
+  "//third_party/libvpx/source/libvpx/vpx_mem/vpx_mem.c",
+  "//third_party/libvpx/source/libvpx/vpx_mem/vpx_mem.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/bitops.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/emmintrin_compat.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem_ops.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/mem_ops_aligned.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/msvc.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/ppc.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/ppc_cpudetect.c",
+  "//third_party/libvpx/source/libvpx/vpx_ports/system_state.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/vpx_once.h",
+  "//third_party/libvpx/source/libvpx/vpx_ports/vpx_timer.h",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/gen_scalers.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/vpx_scale.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/yv12config.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/generic/yv12extend.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/vpx_scale.h",
+  "//third_party/libvpx/source/libvpx/vpx_scale/vpx_scale_rtcd.c",
+  "//third_party/libvpx/source/libvpx/vpx_scale/yv12config.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/endian_inl.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_atomics.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_thread.c",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_thread.h",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.c",
+  "//third_party/libvpx/source/libvpx/vpx_util/vpx_write_yuv_frame.h",
+]
+libvpx_srcs_ppc64_assembly = []
 libvpx_srcs_nacl = [
   "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.c",
   "//third_party/libvpx/source/libvpx/vp8/common/alloccommon.h",
-- 
2.17.1

From 2b977a504b2f0f7634d44d7fde991259eaacf276 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Sat, 1 Sep 2018 16:43:48 -0500
Subject: [PATCH] Add support for ppc64

---
 chromium/scripts/build_ffmpeg.py         | 11 +++++++++--
 chromium/scripts/copy_config.sh          |  2 +-
 chromium/scripts/generate_gn.py          |  2 +-
 chromium/scripts/generate_gn_unittest.py |  3 ++-
 4 files changed, 13 insertions(+), 5 deletions(-)

diff --git a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py b/chromium/scripts/build_ffmpeg.py
index 309d7b9a00..ca316dd24d 100755
--- a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
+++ b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
@@ -36,7 +36,7 @@ ARCH_MAP = {
     'android': ['ia32', 'x64', 'mipsel', 'mips64el', 'arm-neon', 'arm64'],
     'linux': [
         'ia32', 'x64', 'mipsel', 'mips64el', 'noasm-x64', 'arm', 'arm-neon',
-        'arm64'
+        'arm64', 'ppc64'
     ],
     'mac': ['x64'],
     'win': ['ia32', 'x64'],
@@ -128,6 +128,8 @@ def DetermineHostOsAndArch():
     host_arch = 'mips64el'
   elif platform.machine().startswith('arm'):
     host_arch = 'arm'
+  elif platform.machine() == 'ppc64le':
+    host_arch = 'ppc64'
   else:
     return None
 
@@ -746,6 +748,11 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
             '--extra-cflags=--target=mips64el-linux-gnuabi64',
             '--extra-ldflags=--target=mips64el-linux-gnuabi64',
         ])
+    elif target_arch == 'ppc64':
+      configure_flags['Common'].extend([
+        '--arch=ppc64le',
+        '--extra-cflags=-mcpu=power9'
+      ])
     else:
       print(
           'Error: Unknown target arch %r for target OS %r!' % (target_arch,
@@ -771,7 +778,7 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
     # typically be the system one, so explicitly configure use of Clang's
     # ld.lld, to ensure that things like cross-compilation and LTO work.
     # This does not work for arm64, ia32 and is always used on mac.
-    if target_arch not in ['arm64', 'ia32', 'mipsel'] and target_os != 'mac':
+    if target_arch not in ['arm64', 'ia32', 'mipsel', 'ppc64'] and target_os != 'mac':
       configure_flags['Common'].append('--extra-ldflags=-fuse-ld=lld')
 
   # Should be run on Mac, unless we're cross-compiling on Linux.
diff --git a/third_party/ffmpeg/chromium/scripts/copy_config.sh b/chromium/scripts/copy_config.sh
index 0e5159d6f4..7e4e8175f7 100755
--- a/third_party/ffmpeg/chromium/scripts/copy_config.sh
+++ b/third_party/ffmpeg/chromium/scripts/copy_config.sh
@@ -10,7 +10,7 @@ for os in android linux linux-noasm mac win; do
     # Copy config files for various architectures:
     #   - ia32/x64 have config.asm, config.h
     #   - arm/arm-neon have config.h
-    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el; do
+    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el ppc64; do
       # Don't waste time on non-existent configs, if no config.h then skip.
       [ ! -e "build.$arch.$os/$target/config.h" ] && continue
       for f in config.h config.asm libavutil/avconfig.h libavutil/ffversion.h libavcodec/bsf_list.c libavcodec/codec_list.c libavcodec/parser_list.c libavformat/demuxer_list.c libavformat/muxer_list.c libavformat/protocol_list.c; do
diff --git a/third_party/ffmpeg/chromium/scripts/generate_gn.py b/chromium/scripts/generate_gn.py
index b4adb7f45c..7191648231 100755
--- a/third_party/ffmpeg/chromium/scripts/generate_gn.py
+++ b/third_party/ffmpeg/chromium/scripts/generate_gn.py
@@ -77,7 +77,7 @@ GN_SOURCE_END = """]
 Attr = enum('ARCHITECTURE', 'TARGET', 'PLATFORM')
 SUPPORT_MATRIX = {
     Attr.ARCHITECTURE:
-        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon', 'mipsel', 'mips64el']),
+        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon', 'mipsel', 'mips64el', 'ppc64']),
     Attr.TARGET:
         set(['Chromium', 'Chrome', 'ChromeOS']),
     Attr.PLATFORM:
diff --git a/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py b/chromium/scripts/generate_gn_unittest.py
index c4c2faf614..4ba85171a2 100755
--- a/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py
+++ b/third_party/ffmpeg/chromium/scripts/generate_gn_unittest.py
@@ -324,6 +324,10 @@
     f = SourceSet(
         set(['common', 'arm-neon', 'chrome', 'chromeos']),
         set([SourceListCondition('arm-neon', 'ChromeOS', 'linux')]))
+    g = SourceSet(
+        set(['common']),
+        set([SourceListCondition('ppc64', 'Chromium', 'linux')]))
+
 
     expected = set()
     expected.add(
@@ -335,7 +339,8 @@
                 SourceListCondition('x64', 'Chromium', 'linux'),
                 SourceListCondition('x64', 'Chrome', 'linux'),
                 SourceListCondition('arm', 'Chromium', 'linux'),
-                SourceListCondition('arm-neon', 'ChromeOS', 'linux')
+                SourceListCondition('arm-neon', 'ChromeOS', 'linux'),
+                SourceListCondition('ppc64', 'Chromium', 'linux')
             ])))
     expected.add(
         SourceSet(
@@ -363,7 +368,7 @@
             set(['arm-neon', 'chromeos']),
             set([SourceListCondition('arm-neon', 'ChromeOS', 'linux')])))
 
-    source_sets = gg.CreatePairwiseDisjointSets([a, b, c, d, e, f])
+    source_sets = gg.CreatePairwiseDisjointSets([a, b, c, d, e, f, g])
     self.assertEqualSourceSets(expected, set(source_sets))
 
   def testReduceConditions(self):
@@ -378,6 +383,7 @@
             SourceListCondition('arm-neon', 'Chromium', 'linux'),
             SourceListCondition('mipsel', 'Chromium', 'linux'),
             SourceListCondition('mips64el', 'Chromium', 'linux'),
+            SourceListCondition('ppc64', 'Chromium', 'linux'),
         ]))
     gg.ReduceConditionalLogic(a)
 
-- 
2.17.1

From b3a14db7637232d30c878cc1f1ad6d8037e81379 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawn@anastas.io>
Date: Tue, 15 Jan 2019 22:42:21 -0600
Subject: [PATCH] linux/seccomp-bpf: ppc64+glibc workaround in SIGSYS handler

Workaround for an apparent issue with glibc negating syscall
parameters. Observed on a ppc64le machine with glibc.
More investigation required.
---
 sandbox/linux/seccomp-bpf/trap.cc | 14 ++++++++++++++
 1 file changed, 14 insertions(+)

diff --git a/sandbox/linux/seccomp-bpf/trap.cc b/sandbox/linux/seccomp-bpf/trap.cc
index 003708d2c8..8f9b3af4e2 100644
--- a/sandbox/linux/seccomp-bpf/trap.cc
+++ b/sandbox/linux/seccomp-bpf/trap.cc
@@ -225,6 +225,20 @@ void Trap::SigSys(int nr, LinuxSigInfo* info, ucontext_t* ctx) {
       SetIsInSigHandler();
     }
 
+#if defined(__powerpc64__)
+    // On ppc64+glibc, some syscalls seem to accidentally negate the first
+    // parameter which causes checks against it to fail. For now, manually
+    // negate them back.
+    // TODO(shawn@anastas.io): investigate this issue further
+    auto nr = SECCOMP_SYSCALL(ctx);
+    if (nr == __NR_openat || nr == __NR_mkdirat || nr == __NR_faccessat || nr == __NR_readlinkat ||
+        nr == __NR_renameat || nr == __NR_renameat2 || nr == __NR_newfstatat || nr == __NR_unlinkat) {
+        if (static_cast<int>(SECCOMP_PARM1(ctx)) > 0) {
+            SECCOMP_PARM1(ctx) = -SECCOMP_PARM1(ctx);
+        }
+    }
+#endif
+
     // Copy the seccomp-specific data into a arch_seccomp_data structure. This
     // is what we are showing to TrapFnc callbacks that the system call
     // evaluator registered with the sandbox.
-- 
2.20.1

From 0c65e40ae578b743b5f06956597ebc9700768d18 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Thu, 9 Aug 2018 22:45:47 -0500
Subject: [PATCH 1/1] sandbox: Enable seccomp_bpf for ppc64

---
 sandbox/features.gni | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sandbox/features.gni b/sandbox/features.gni
index 89693c54c4f5..6017c7eea95e 100644
--- a/sandbox/features.gni
+++ b/sandbox/features.gni
@@ -12,6 +12,6 @@ use_seccomp_bpf =
     (is_linux || is_android) &&
     (current_cpu == "x86" || current_cpu == "x64" || current_cpu == "arm" ||
      current_cpu == "arm64" || current_cpu == "mipsel" ||
-     current_cpu == "mips64el")
+     current_cpu == "mips64el" || current_cpu == "ppc64")
 
 use_seccomp_bpf = use_seccomp_bpf || is_nacl_nonsfi
-- 
2.17.1

From c9043a422fb4a5a6c72aaa1b907cea5f6a3061dd Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Thu, 9 Aug 2018 19:10:24 -0500
Subject: [PATCH 1/4] sandbox/linux/bpf_dsl: Update syscall ranges for ppc64

---
 sandbox/linux/bpf_dsl/linux_syscall_ranges.h | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
index 334a00bb9136..272d65b2ae3d 100644
--- a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
+++ b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
@@ -53,6 +53,13 @@
 #define MAX_PUBLIC_SYSCALL 279u
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__powerpc64__)
+
+#include <asm/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL 386u
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
-- 
2.17.1

From 036d209a3f1a771de9aed31dfbe804aaf91d1c27 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Thu, 9 Aug 2018 23:35:21 -0500
Subject: [PATCH] sandbox/linux: Implement partial support for ppc64 syscalls
 and ucontext

Unlike other architectures, the ppc64 files currently rely on applicable
headers being provided by the system. It is sufficient for standard
GNU/Linux environments, but may require expansion elsewhere.
---
 sandbox/linux/BUILD.gn                              |  2 ++
 sandbox/linux/system_headers/linux_syscalls.h       |  4 ++++
 sandbox/linux/system_headers/linux_ucontext.h       |  2 ++
 sandbox/linux/system_headers/ppc64_linux_syscalls.h | 12 ++++++++++++
 sandbox/linux/system_headers/ppc64_linux_ucontext.h | 12 ++++++++++++
 5 files changed, 32 insertions(+)
 create mode 100644 sandbox/linux/system_headers/ppc64_linux_syscalls.h
 create mode 100644 sandbox/linux/system_headers/ppc64_linux_ucontext.h

diff --git a/sandbox/linux/BUILD.gn b/sandbox/linux/BUILD.gn
index 754fe5a50b32..fa54258ce16c 100644
--- a/sandbox/linux/BUILD.gn
+++ b/sandbox/linux/BUILD.gn
@@ -416,6 +416,8 @@ component("sandbox_services") {
 
 source_set("sandbox_services_headers") {
   sources = [
+    "system_headers/ppc64_linux_syscalls.h",
+    "system_headers/ppc64_linux_ucontext.h",
     "system_headers/arm64_linux_syscalls.h",
     "system_headers/arm64_linux_ucontext.h",
     "system_headers/arm_linux_syscalls.h",
diff --git a/sandbox/linux/system_headers/linux_syscalls.h b/sandbox/linux/system_headers/linux_syscalls.h
index 761c08abec76..28ebf2f4eb8d 100644
--- a/sandbox/linux/system_headers/linux_syscalls.h
+++ b/sandbox/linux/system_headers/linux_syscalls.h
@@ -33,5 +33,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff --git a/sandbox/linux/system_headers/linux_ucontext.h b/sandbox/linux/system_headers/linux_ucontext.h
index e97d7277d3d4..f3f05849ad12 100644
--- a/sandbox/linux/system_headers/linux_ucontext.h
+++ b/sandbox/linux/system_headers/linux_ucontext.h
@@ -11,6 +11,8 @@
 #include "sandbox/linux/system_headers/arm_linux_ucontext.h"
 #elif defined(__i386__)
 #include "sandbox/linux/system_headers/i386_linux_ucontext.h"
+#elif defined(__powerpc64__)
+#include "sandbox/linux/system_headers/ppc64_linux_ucontext.h"
 #else
 #error "No support for your architecture in PNaCl header"
 #endif
diff --git a/sandbox/linux/system_headers/ppc64_linux_syscalls.h b/sandbox/linux/system_headers/ppc64_linux_syscalls.h
new file mode 100644
index 000000000000..ccacffe22ea3
--- /dev/null
+++ b/sandbox/linux/system_headers/ppc64_linux_syscalls.h
@@ -0,0 +1,12 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
+
+#include <asm/unistd.h>
+
+//TODO: is it necessary to redefine syscall numbers for PPC64?
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_SYSCALLS_H_
diff --git a/sandbox/linux/system_headers/ppc64_linux_ucontext.h b/sandbox/linux/system_headers/ppc64_linux_ucontext.h
new file mode 100644
index 000000000000..07728e087911
--- /dev/null
+++ b/sandbox/linux/system_headers/ppc64_linux_ucontext.h
@@ -0,0 +1,12 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
+
+#include <sys/ucontext.h>
+
+//TODO: is it necessary to redefine ucontext on PPC64?
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_PPC64_LINUX_UCONTEXT_H_
-- 
2.17.1

From c41cd6ac927f592b161abc04468d3c7a4be91995 Mon Sep 17 00:00:00 2001
From: Shawn Anastasio <shawnanastasio@yahoo.com>
Date: Tue, 23 Oct 2018 15:49:31 -0500
Subject: [PATCH] sandbox/linux: Update IsSyscallAllowed in broker_process.cc

---
 sandbox/linux/syscall_broker/broker_process.cc | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/sandbox/linux/syscall_broker/broker_process.cc b/sandbox/linux/syscall_broker/broker_process.cc
index 82ab4a76c2..9357de2326 100644
--- a/sandbox/linux/syscall_broker/broker_process.cc
+++ b/sandbox/linux/syscall_broker/broker_process.cc
@@ -151,7 +151,7 @@ bool BrokerProcess::IsSyscallAllowed(int sysno) const {
 #if defined(__NR_fstatat)
     case __NR_fstatat:
 #endif
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__powerpc64__)
     case __NR_newfstatat:
 #endif
       return !fast_check_in_client_ || allowed_command_set_.test(COMMAND_STAT);
-- 
2.17.2

